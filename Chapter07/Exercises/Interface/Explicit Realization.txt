При явной реализации указывается название метода или свойства вместе с названием интерфейса.
При этом при реализации мы не можем использовать какие-либо модификаторы:

interface IAction
{
    void Move();
}
class BaseAction : IAction
{
    void IAction.Move() => Console.WriteLine("Move in Base Class");
}





Следует учитывать, что при явной реализации интерфейса его методы и свойства не являются частью интерфейса класса.
(Явная реальзация - это когда перед классом ставятся скобки и в них указывается значение к которому мы хотим преобразовать =>
=> (IAction)baseAction1. в таком случае мы не можем обратиться напрямую (через точку - car.Move()) методам или свойствам 
этого объекта)
Поэтому напрямую через объект класса мы к ним обратиться не сможем:

BaseAction baseAction1 = new BaseAction();
 
// baseAction1.Move();  // ! Ошибка - в BaseAction нет метода Move
// необходимо приведение к типу IAction
// небезопасное приведение
((IAction)baseAction1).Move();   
// безопасное приведение 
if (baseAction1 is IAction action) action.Move();
// или так
IAction baseAction2 = new BaseAction();
baseAction2.Move();


Однако, если преобразование проходит неявно (то есть без скобочек - не (IAction)baseAction1), то все проходит успешно и теперь
методы и свойства модно снова вызывать:

Message hello = new Message("Hello World");
hello.Print();  // Hello World
 
interface IMessage
{
    string Text { get; set; }
}
interface IPrintable
{
    void Print();
}
class Message : IMessage, IPrintable
{
    public string Text { get; set; }
    public Message(string text) => Text = text;
    public void Print()=> Console.WriteLine(Text);
}





В какой ситуации может действительно понадобиться явная реализация интерфейса? 

Например, когда класс применяет несколько интерфейсов, но они имеют один и тот же метод с одним и тем же возвращаемым результатом
и одним и тем же набором параметров:

