Применение интерфейсов

Интерфейс представляет некое описание типа, набор компонентов, который должен иметь тип данных. 
И, собственно, мы не можем создавать объекты интерфейса напрямую с помощью конструктора, как например, в классах:


IMovable m = new IMovable(); // ! Ошибка, так сделать нельзя
 
interface IMovable
{
    void Move();
}




В конечном счете интерфейс предназначен для реализации в классах и структурах. 
Например, реализуем выше определенный интерфейс IMovable:


// применение интерфейса в классе
class Person : IMovable
{
    public void Move()
    {
        Console.WriteLine("Человек идет");
    }
}
// применение интерфейса в структуре
struct Car : IMovable
{
    public void Move()
    {
        Console.WriteLine("Машина едет");
    }
}

При применении интерфейса, как и при наследовании после имени класса или структуры указывается двоеточие 
и затем идут названия применяемых интерфейсов. При этом класс должен реализовать все методы и свойства применяемых интерфейсов, 
если эти методы и свойства не имеют реализации по умолчанию.



Применение интерфейса в программе:

Person person = new Person();
Car car = new Car();
DoAction(person);
DoAction(car);
 
void DoAction(IMovable movable) => movable.Move();
 
interface IMovable
{
    void Move();
}
class Person : IMovable
{
    public void Move() => Console.WriteLine("Человек идет");
}
struct Car : IMovable
{
    public void Move() => Console.WriteLine("Машина едет");
}




Реализация интерфейсов по умолчанию

Начиная с версии C# 8.0 интерфейсы поддерживают реализацию методов и свойств по умолчанию. Зачем это нужно? 
Допустим, у нас есть куча классов, которые реализуют некоторый интерфейс. Если мы добавим в этот интерфейс новый метод, 
то мы будем обязаны реализовать этот метод во всех классах, применяющих данный интерфейс. 
Иначе подобные классы просто не будут компилироваться. Теперь вместо реализации метода во всех классах нам достаточно определить 
его реализацию по умолчанию в интерфейсе. Если класс не реализует метод, будет применяться реализация по умолчанию.


IMovable tom = new Person();
Car tesla = new Car();
tom.Move();     // Walking
tesla.Move();   // Driving
interface IMovable
{
    void Move() => Console.WriteLine("Walking");
}
class Person : IMovable { }
class Car : IMovable
{
    public void Move() => Console.WriteLine("Driving");
}


Стоит отметить, что хотя для объекта класса Person мы можем вызвать метод Move - ведь класс Person применяет интерфейс IMovable, 
тем не менее мы не можем написать так:

Person tom = new Person();
tom.Move();     // Ошибка - метод Move не определен в классе Person




Множественная реализация интерфейсов
Интерфейсы имеют еще одну важную функцию: в C# не поддерживается множественное наследование, 
то есть мы можем унаследовать класс только от одного класса, в отличие, скажем, от языка С++, 
где множественное наследование можно использовать. Интерфейсы позволяют частично обойти это ограничение, 
поскольку в C# классы и структуры могут реализовать сразу несколько интерфейсов. Все реализуемые интерфейсы указываются через запятую:


class myClass: myInterface1, myInterface2, myInterface3, ...
{
     
}




Рассмотрим на примере:

Message hello = new Message("Hello World");
hello.Print();  // Hello World
 
interface IMessage
{
    string Text { get; set; }
}
interface IPrintable
{
    void Print();
}
class Message : IMessage, IPrintable
{
    public string Text { get; set; }
    public Message(string text) => Text = text;
    public void Print()=> Console.WriteLine(Text);
}




